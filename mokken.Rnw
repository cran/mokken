\documentclass[11pt,a4paper]{report}
\usepackage{graphicx,lscape}
\usepackage[colorlinks, bookmarks=true, breaklinks=true, linkcolor=black]{hyperref}
\newtheorem{example}{Example}
\newcommand{\inputfont}{\normalsize}
% \VignetteIndexEntry{Getting Started with Mokken Scale Analysis in R}

\begin{document}
\title{Getting Started with Mokken Scale Analysis in R}
\author{Andries van der Ark}
\maketitle
\chapter{Getting started}
\label{chapter.1}
\section{Introduction}
This report aims at researchers who have Windows installed on their computer and who wish to
 conduct Mokken scale analysis using the freeware R-package
\texttt{mokken} (Van der Ark, 2007) but who do not know anything about R.
It is a step by step guide from scratch to actually performing Mokken scale analysis.
A more elaborate book on learning R for SPSS and SAS users is Muenchen (2008).
The report is organized as follows.
In this chapter (chap.~\ref{chapter.1}), I discuss the preparations that are needed before \texttt{mokken} can be used.
In section~\ref{installation}, I discuss the installation of R and all the necessary packages.
In section~\ref{convert}, I discuss how SPSS, SAS, STATA, and Splus data sets should be converted to R.
In section~\ref{R.commands}, I show a few R commands that come in handy for data manipulation (e.g., variable selection).
In chapter~\ref{chapter.2}, I explain \texttt{mokken}.
In section~\ref{mokken.commands}, I give an overview of \texttt{mokken}'s most important commands (known as \emph{functions} in R)
 illustrated by examples.
In section~\ref{example}, I explain the use of \texttt{mokken} by showing the code for most
 analyses in the book \emph{Introduction to nonparametric item response theory} (Sijtsma \& Molenaar, 2003).
% In chapter~\ref{chapter.3}, I discuss how \texttt{mokken} can be implemented in SPSS.

The report can be read best from a computer screen because it contains colored text:
 \textcolor{magenta}{internet links}, \textcolor{red}{R code}, \textcolor{blue}{R results},
 and \textcolor{blue}{Links as they appear on the R websites}.
The R code may be selected from the document and pasted into the R console.

\section{Installation}
\label{installation}

\subsection{What is R?}
R (R Development Core Team, 2006) is a language and environment for statistical computing and graphics.
It is something in between a statistical package such as SPSS, STATA, or SAS and a programming language
 such as C++, PASCAL, or FORTRAN.
It has two big advantages: It is for free and it has open source.
Because it is for free it is accessible for anyone at any time, and because it has an open source
 researchers can add \emph{packages} to R.
Currently, over 2100 packages are added --- the package \texttt{mokken} is one of them --- allowing the user
 to conduct almost every possible statistical procedure ranging from common statistical procedures,
 which are also available in commercial software packages, to statistical techniques such as item response theory,
 spectral analysis, marginal modelling, Bayesian analysis, and latent class analysis.
Every two months or so R releases a new version. At the time of writing version R-2.10.1 was the most recent version.
Although, it is good to have a recent version of R, I only update a new version once a year or so.
The major R website is \url{http://cran.r-project.org/}.
It contains an abundance of information.
A special page is devoted to packages that are of interest to psychometricians \\
(\url{http://cran.r-project.org/web/views/Psychometrics.html}).

\subsection{Installing R}
Installing R requires the following steps
\begin{enumerate}
 \item Go to \url{http://cran.r-project.org/}.
 \item Click on \textcolor{blue}{Windows} (See Figure~\ref{F1})
\begin{figure}
\begin{center}
 \includegraphics[width=8cm]{F1.eps}
\end{center}
\caption{\label{F1} \emph{R website. Click on
\textcolor{blue}{Windows}.}}
\end{figure}
 \item Click on \textcolor{blue}{base} (See Figure~\ref{F2})
\begin{figure}
\begin{center}
 \includegraphics[width=8cm]{F2.eps}
\end{center}
\caption{\label{F2} \emph{R website. Click on \textcolor{blue}{base}.}}
\end{figure}
 \item Click on \textcolor{blue}{Download R 2.10.1 for Windows} (or a more recent version; see Figure~\ref{F3})
\begin{figure}
\begin{center}
 \includegraphics[width=8cm]{F3.eps}
\end{center}
\caption{\label{F3} \emph{R website. Click on \textcolor{blue}{\textcolor{blue}{Download R 2.10.1 for Windows}}.}}
\end{figure}
 \item Save the file \texttt{R-2.10.1-win32.exe} on your computer (e.g., on \texttt{C:/}).
 \item Run the file \texttt{R-2.10.1-win32.exe} from your computer. You can choose all the default values
       in the installation Wizard.
 \item R will be available from the desk top icon, and from the programme's menu.
\end{enumerate}


\subsection{Installing the package \texttt{mokken}}
\label{install.package}
\begin{enumerate}
 \item Open R (Figure~\ref{F4} shows the \emph{R console}).
\begin{figure}
\begin{center}
 \includegraphics[width=8cm, angle=90]{F4.eps}
\end{center}
\caption{\label{F4} \emph{R console.}}
\end{figure}
 \item In the pull down menu choose \texttt{Packages}, \texttt{Install package(s)}, choose a location nearby you, and choose the package \texttt{mokken} (Figure~\ref{F7}).

\begin{figure}
\begin{center}
  \includegraphics[width=8cm, angle=90]{F7.eps}
\end{center}
\caption{\label{F7} \emph{R console}. Choose \texttt{mokken}.}
\end{figure}

\end{enumerate}
The package \texttt{mokken} is now installed on your computer and need not be installed anymore.
It may be noted that the same procedure applies to the installation of all packages.

\subsection{Working with R}
Except for loading packages (section~\ref{install.package}), almost everything in R is conducted by typing
 (or pasting) code in the R console (Figure~\ref{F4}) just after the prompt (\textcolor{red}{$>$}) and end with
  hard return (Enter).
Code to be typed is printed in  \emph{\texttt{slanted typewriter text}} and preceded by a \emph{$\mathtt{>}$} (a prompt).
The resulting output is printed exactly as it is printed on the screen in \texttt{typewrite text}.
Note that R is case sensitive.
Some examples.
\begin{description}
\item
{\inputfont
<<label=intro1>>=
6 - 3
@
}

\item
{\inputfont
<<label=intro2>>=
options(width=60)
x <- sqrt(2)
x
@
}

R assigns the value $\sqrt{2}$ to variable $x$ (line 1) and displays the value of $x$ (line 2)
\item To load the procedures of \texttt{mokken} into the memory of R type

{\inputfont
<<label=intro3>>=
library(mokken)
@
}

\item To quit R, type

{\inputfont
<<label=intro5, eval=FALSE>>=
q()
@
}

\end{description}

Free of charge introductions to R are available on the Internet.
\begin{itemize}
 \item R Development Core Team (2009). \emph{An Introduction to R}. Retrieved from
    \url{http://cran.r-project.org/doc/manuals/R-intro.html} (html) or
     \url{http://cran.r-project.org/doc/manuals/R-intro.pdf} (pdf).
 \item Paradis, E. (2005). \emph{R for beginners}. Retrieved from
  \url{http://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf}
\item Baron, J., \& Li, Y. (2007).
  \emph{Notes on the use of R for psychology experiments and questionnaires}. Retrieved from
  \url{http://www.psych.upenn.edu/~baron/rpsych/rpsych.html}
\end{itemize}
Many more sources are available from \url{http://cran.r-project.org/} (Contributed Documentation).

\section{Converting data to R and back again}
\label{convert}

Converting a data set from a commercial package to R is the Achilles Heel of Mokken scale analysis in R.
Commercial packages have no interest in free software that can easily read their data sets and these companies
 put no effort making their data files compatible with R.
As a result, small things that you may not be aware of (e.g., whether your computer uses a point or
 a comma as a decimal separator, whether or not the rows in your data set have labels) may affect the
 conversion.
An elaborated manual for converting many types of files in to files that can be read by R is available from
\url{http://cran.r-project.org/doc/manuals/R-data.html}.
Here only conversions to and from SPSS, SAS, STATA, and Splus are briefly discussed.
The fasted strategy is to read the SPSS, SAS, STATA, or Splus file directly in R.
Direct reading may occasionally go wrong and an alternative option is to save the SPSS, SAS, STATA, or Splus file
 as a text-only file (ASCII file), and read the ASCII file into R.
In the latter procedure, the variable names may get lost.

\subsection{SPSS files}

\subsubsection{Converting SPSS files directly}
I assume that an SPSS data set named \texttt{ExampleSPSS.sav} has been saved on \texttt{C:/ }\footnote{\texttt{ExampleSPSS.sav} is a completely arbitrary name and your data set probably has a different name and may be located on another drive than \texttt{C:/ }. Therefore, you should replace \texttt{C:/ExampleSPSS.sav} by your complete path and file name. The SPSS-file is not included in the Mokken package.} .

\begin{enumerate}

 \item Type the following code in the R console

{\inputfont
<<label=spss1,eval=FALSE>>=
library(foreign)
ExampleR <- data.frame(read.spss("C:/ExampleSPSS.sav"))
fix(ExampleR)
@
}

 Note that \texttt{data.frame()} is an R function; it saves the data in a matrix-like manner, allowing different measurement levels for the scores in each column.
 Most data sets in R belong to the class \texttt{data.frame}.
 The data file is now stored in the memory of R under the name \texttt{ExampleR}\footnote{Again \texttt{ExampleR} is a completely arbitrary name and you may decide to name it differently, for example, \texttt{NKSPdata2008}.}.
 The last command is not necessary. It opens the R data in a spread sheet in another window in R; the spreadsheet can be used to check whether the transformation went well.
 If necessary, the spread sheet may be modified. If the spreadsheet window is closed (by clicking the close button in the upper right-hand corner, see Figure~\ref{CloseWindow}) the changes are saved.
 Note that \texttt{library(foreign)} may be omitted, if it has been typed in before during the same R session.

 \item If R is closed, \texttt{ExampleR} are lost. Therefore, the data should be saved in an R format
  that can be retrieved easily. To save the data (in the file \texttt{C:/ExampleR.Rdata}) type

{\inputfont
<<label=spss2,eval=FALSE>>=
save(ExampleR, file="C:/ExampleR.Rdata")
@
}

To get the data back into R type

{\inputfont
<<label=spss2,eval=FALSE>>=
load("C:/ExampleR.Rdata")
@
}

\end{enumerate}

\begin{figure}
\begin{center}
 \includegraphics[width=8cm, angle=90]{F8.eps}
\end{center}
\caption{\label{CloseWindow} \emph{Close the spreadsheet by clicking the button in the upper right-hand corner}}
\end{figure}


\subsubsection{Saving SPSS files as ASCII files and read the ASCII files}

Save the data as a tab delimited ASCII file (.dat file)
This format can be read easily by R.
The SPSS syntax is
\begin{verbatim}
SAVE TRANSLATE OUTFILE='C:\ExampleSPSS2.dat'
  /TYPE=TAB
  /MAP
  /REPLACE
  /FIELDNAMES
  /CELLS=LABELS.
\end{verbatim}

\subsubsection{Converting R data to SPSS}

To convert R data sets to SPSS directly is impossible.
R creates an SPSS syntax file and an ASCII data file.
The SPSS syntax file should be run within SPSS.
To create the syntax file \texttt{"ExampleSPSS.SPS"} and the data file \texttt{"ExampleSSPS.txt"} from the
 R data \texttt{ExampleR}, type

{\inputfont
<<label=spss3,eval=FALSE>>=
library(foreign)
write.foreign(ExampleR, datafile="C:/ExampleSPSS.txt", codefile="C:/ExampleSPSS.SPS", package="SPSS")
@
}
\subsection{SAS XPORT files}

\subsubsection{Converting SAS XPORT files directly}
I assume that the SAS data set \texttt{ExampleSAS.xpt} has been saved on \texttt{C:/}.
\begin{enumerate}
 \item Type the following code in the R console

{\inputfont
<<label=sas1,eval=FALSE>>=
library(foreign)
ExampleR <- data.frame(read.xport("C:/ExampleSAS.xpt"))
fix(ExampleR)
@
}

The data file is now stored in the memory of R under the name \texttt{ExampleR}.
The last command is not necessary. It opens the R data in a spread sheet, which can be used to check whether the transformation went well.
If necessary, the spread sheet may be modified. If the spread-sheet window is closed the changes are saved.
Note that \texttt{library(foreign)} may be omitted, if it has been typed in before during the same R session.
 \item If R is closed, \texttt{ExampleR} are lost. Therefore, the data should be saved in an R format
  that can be retrieved easily. To save the data (in the file \texttt{C:/ExampleR.Rdata}) type

{\inputfont
<<label=sas2,eval=FALSE>>=
save(ExampleR, file="C:/ExampleR.Rdata")
@
}

To get the data back into R type

{\inputfont
<<label=sas3,eval=FALSE>>=
load("C:/ExampleR.Rdata")
@
}

\end{enumerate}

\subsubsection{Converting R data to SAS}

To convert R data sets to SAS directly is impossible.
R creates a SAS syntax file and an ASCII data file.
The SAS syntax file should be run within SAS.
To create the syntax file \texttt{"ExampleSAS.XXX"} and the data file \texttt{"ExampleSAS.txt"} from the
 R data \texttt{ExampleR}, type

{\inputfont
<<label=sas4,eval=FALSE>>=
library(foreign)
write.foreign(ExampleR, datafile="C:/ExampleSAS.txt",codefile="C:/ExampleSAS.XXX", package="SAS")
@
}
\subsection{STATA files}

\subsubsection{Converting STATA files directly}
I assume that the STATA data set \texttt{ExampleSTATA.dta} has been saved on \texttt{C:/}.
\begin{enumerate}
 \item Type the following code in the R console

{\inputfont
<<label=stat1,eval=FALSE>>=
library(foreign)
ExampleR <- data.frame(read.dta("C:/ExampleSTATA.dta"))
fix(ExampleR)
@
}

The data file is now stored in the memory of R under the name \texttt{ExampleR}.
The last command is not necessary. It opens the R data in a spread sheet, which can be used to check whether the transformation went well.
If necessary, the spread sheet may be modified. If the spread-sheet window is closed the changes are saved.
Note that \texttt{library(foreign)} may be omitted, if it has been typed in before during the same R session.
 \item If R is closed, \texttt{ExampleR} are lost. Therefore, the data should be saved in an R format
  that can be retrieved easily. To save the data (in the file \texttt{C:/ExampleR.Rdata}) type

{\inputfont
<<label=stat2,eval=FALSE>>=
save(ExampleR, file="C:/ExampleR.Rdata")
@
}

To get the data back into R type

{\inputfont
<<label=stat3,eval=FALSE>>=
load("C:/ExampleR.Rdata")
@
}

\end{enumerate}

\subsubsection{Converting R data to STATA}

To convert R data sets to STATA directly is impossible.
R creates a STATA syntax file and an ASCII data file.
The STATA syntax file should be run within STATA.
To create the syntax file \texttt{"ExampleSTATA.do"} and the data file \texttt{"ExampleSTATA.dat"} from the
 R data \texttt{ExampleR}, type

{\inputfont
<<label=stat1,eval=FALSE>>=
library(foreign)
write.foreign(ExampleR, datafile="C:/ExampleSTATA.dat", codefile="C:/ExampleSTATA.do", package="Stata")
@
}

\subsection{Splus files}
% dump("transitief.oktober",fileout="G:/werk/data/transitief/transitief.dmp")

\subsubsection{Converting Splus files directly}
I assume that the Splus data set \texttt{ExampleSplus.ssc} has been saved on \texttt{C:/}.
\begin{enumerate}
 \item Type the following code in the R console

{\inputfont
<<label=splus1,eval=FALSE>>=
library(foreign)
ExampleR <- data.frame(read.s("C:/ExampleSplus.ssc"))
fix(ExampleR)
@
}

The data file is now stored in the memory of R under the name \texttt{ExampleR}.
The last command is not necessary. It opens the R data in a spread sheet, which can be used to check whether the transformation went well.
If necessary, the spread sheet may be modified. If the spread-sheet window is closed the changes are saved.
Note that \texttt{library(foreign)} may be omitted, if it has been typed in before during the same R session.
 \item If R is closed, \texttt{ExampleR} are lost. Therefore, the data should be saved in an R format
  that can be retrieved easily. To save the data (in the file \texttt{C:/ExampleR.Rdata}) type

{\inputfont
<<label=splus2,eval=FALSE>>=
save(ExampleR, file="C:/ExampleR.Rdata")
@
}

To get the data back into R type

{\inputfont
<<label=splus3,eval=FALSE>>=
load("C:/ExampleR.Rdata")
@
}

\end{enumerate}

\subsubsection{Converting Splus objects to R objects}
I assume that the you have an Splus object \texttt{ExampleSplus} in Splus, and that all data can be stored in \texttt{C:/}.
Type in the Splus console

{\inputfont
<<label=splus4,eval=FALSE>>=
dump(ExampleSplus,"C:/Example.dmp")
@
}

Next, type in the R console

{\inputfont
<<label=splus5,eval=FALSE>>=
ExampleR <- dget("C:/Example.dmp")
@
}

\section{R commands required for \texttt{mokken}}
\label{R.commands}

Rather than typing commands in the R console, I advice to type the commands in a plain text file, save the file,
and paste a command or a series of commands into R. In this way the commands will not be lost.
\begin{itemize}
 \item If \texttt{mokken} is used, then one should start each R session with

{\inputfont
<<label=mokken1>>=
library(mokken)
@
}

\item If help is required at any stage use the command \texttt{help()}. For example,

{\inputfont
<<label=mokken2, eval=FALSE>>=
help(mokken)
@
}

  The help file contains examples of \texttt{mokken}. It can be instructive to paste these examples into the R console.
 \item A hash (\texttt{\#}) indicates that everything beyond it on the same line is a comment.

{\inputfont
<<label=mokken3>>=
# help(mokken)
@
}

does not do anything.

\item There are three data sets included in \texttt{mokken}: \texttt{acl}, \texttt{cavalini}, and \texttt{transreas}. Typing

{\inputfont
<<label=mokken4>>=
data(acl)
data(cavalini)
data(transreas)
@
}

makes them available in R. Note that without these \texttt{data()} commands, the data sets are are not available.

{\inputfont
<<label=mokken5, eval=FALSE>>=
help(acl)
@
}

will give all the information on \texttt{acl}

{\inputfont
<<label=mokken5, eval=FALSE>>=
fix(cavalini)
@
}

will show \texttt{cavalini} in a spreadsheet.

\item An arrow \texttt{<-} is used for assignment. Examples

{\inputfont
<<label=mokken6>>=
X <- acl
Y <- 3
Z <- c(1,2,3,8:11)
@
}

The value of \texttt{X} is the data matric \texttt{acl} (\texttt{X} and \texttt{acl} are now equivalent).
The value of \texttt{Y} is 3.
The value of \texttt{Z} is the vector (1,2,3,8,9,10,11).
It can be verified by typing\\

{\inputfont
<<label=mokken7>>=
Y
Z
@
}

\item To select columns and rows from the data matrix brackets are used.

{\inputfont
<<label=mokken8>>=
X1 <- acl[,1]
@
}

\texttt{X1} are the scores on the first item `Reliable')

{\inputfont
<<label=mokken9>>=
X2 <- acl[,11:20]
@
}

\texttt{X2} are the scores on items 11 to 20 (i.e., only the scores on the 10 items of the scale `Achievement')

{\inputfont
<<label=mokken10>>=
X3 <- acl[1:10,]
@
}

\texttt{X3} are the scores of the first 10 respondents items on all items

{\inputfont
<<label=mokken11>>=
X4 <- acl[232,133]
@
}

\texttt{X4} is the score of respondent 232 on item 133

{\inputfont
<<label=mokken12>>=
scale.1 <- c(1,2,4)
X5 <- acl[c(1:100,201:300),scale.1]
@
}

\texttt{X5} are the scores of respondents 1-100 and 201-300, on items 1, 2, and 4

{\inputfont
<<label=mokken13>>=
X6 <- acl[acl[,1]==2,]
@
}

\texttt{X6} are the scores of those respondents who had a score 2 on item 1.
\end{itemize}
Note that in data matrices \texttt{X3} to \texttt{X6}, the cases
(rows) not selected are thrown away, and case numbers are not
available. Case numbers can be made through the following
commands. If you want to identify the them, you can create case
numbers for \texttt{acl}.

{\inputfont
<<label=mokken14>>=
dimnames(acl)[[1]] <- 1:nrow(acl)
@
}

If you repeat the analyses above, you may observe that the case
numbers have been preserved.

\chapter{{\textcolor{black}The R package \texttt{mokken}}}
\label{chapter.2}
\section{An overview of the functions}
\label{mokken.commands}
The package \texttt{mokken} consists of the following functions

\subsection{\texttt{aisp}}
Function \texttt{aisp} performs Mokken's (1971) automated item selection algorithm.
In the example, the scores on the first ten items from ACL are used; these are the
 items of the scale Communality.
Mokken's automated item selection algorithm is applied  to the ten items.
The output (in blue) shows that items \texttt{unscrupulous*} and \texttt{unintelligent*}
 are unscalable, that items \texttt{reliable}, \texttt{honest}, \texttt{deceitful*},
 and \texttt{dependable} are in scale 1, and items \texttt{obnoxious*}, \texttt{thankless*},
 \texttt{unfriendly*}, and \texttt{cruel*} are in scale 2.

{\inputfont
<<label=E1>>=
data(acl)
Communality <- acl[,1:10]
scale <- aisp(Communality, verbose=FALSE)
scale
@
}

Variations of \texttt{aisp} (output not shown) are the following
\begin{itemize}
\item  Use a genetic algorithm (Straat, van der Ark, \& Sijtsma, 2010) rather than Mokken's algorithm.

{\inputfont
<<label=E1A, eval=FALSE>>=
scale <- aisp(Communality, search="ga")
@
}

\item Use different values for the lower bound (default \texttt{lowerbound = .3}) and or the nominal type I error rate (default \texttt{alpha = .05})

{\inputfont
<<label=E1B, eval=FALSE>>=
scale  <- aisp(Communality, lowerbound = .2, alpha =.10)
@
}

\item Output on the screen during the item selection (default \texttt{verbose = TRUE})

{\inputfont
<<label=E1C, eval=FALSE>>=
aisp(Communality, verbose=TRUE)
@
}

\item For more information type

{\inputfont
<<label=E1D, eval=FALSE>>=
help(aisp)
@
}

 \end{itemize}

Note that \texttt{search = "{}extend"} has not yet been implemented.

\subsection{\texttt{coefH}}

Computes scalability coefficients $H_{ij}$, $H_i$, and $H$ for a set of items.
In the example, the scores on the first ten items from ACL are used; these are the
items of the scale Communality. First, scalability coefficients $H_{ij}$, $H_i$, and $H$
are computed (no output given here because it is rather voluminous).
Second, only the item scalability coefficients are extracted. Third,
the item scalability coefficients are extracted but rounded to two integers. Fourth, $H$ is extracted.

{\inputfont
<<label=E2>>=
data(acl)
Communality <- acl[,1:10]
coefficients <- coefH(Communality)
coefficients$Hi
round(coefficients$Hi,2)
coefficients$H
@
}

\subsection{\texttt{check.iio}}
 Investigates invariant item ordering (IIO) using method \emph{Manifest IIO} (MIIO; Ligtvoet, Van der Ark,
 Te Marvelde, \& Sijtsma, 2010) and methods \emph{Manifest Scale - Cumulative Probability Model} (MS-CPM) and
 \emph{Increasingness in Transposition} (IT) (Ligtvoet, Van der Ark, Bergsma, \& Sijtsma, 2010).
 Method Manifest IIO is the default.
 First, all result with respect to IIO are
 saved in \texttt{iio.results}. In the example, the scores on the first ten items from ACL are used; these are the
   items of the scale Communality.
 Simply typing \texttt{iio.results} produces a list with lots of output for each item.
   \texttt{summary()} reduces this output by giving a summary of the results.
  The output shows the method used (i.e., Manifest IIO), the violations of manifest IIO, the items selected using
  the backward selection algorithm, and scalability coefficient $H^T$ for the final scale (items \texttt{unfriendly*} and
  \texttt{deceitful*} excluded).

{\inputfont
<<label=E3>>=
data(acl)
Communality <- acl[,1:10]
iio.results <- check.iio(Communality)
summary(iio.results)
@
}

Variations of \texttt{check.iio} (output not shown) are the following.

\begin{itemize}

\item Other values for \texttt{minvi} and \texttt{minsize} (Molenaar \& Sijtsma, 2000, pp.\ 45-46) .

{\inputfont
<<label=E3A,eval=FALSE>>=
check.iio(Communality, minvi=0.00, minsize=50)
@
}

\item Using methods MS-CPM and IT (Ligtvoet, Van der Ark, Bergsma, \& Sijtsma, 2010)

{\inputfont
<<label=E3B,eval=FALSE>>=
summary(check.iio(Communality, method="MS-CPM"))
summary(check.iio(Communality, method="IT"))
@
}

\item Different nominal Type I error rate for t-test (method MIIO), z-test (Method MS-CPM), and McNemar test (method IT).

{\inputfont
<<label=E3C,eval=FALSE>>=
summary(check.iio(Communality, alpha=.01))
@
}

\item Without backward selection algorithm, and with information screen

{\inputfont
<<label=E3D,eval=FALSE>>=
summary(check.iio(Communality, item.selection=FALSE))
summary(check.iio(Communality, verbose=TRUE))
@
}

\item For more information type

{\inputfont
<<label=E3D,eval=FALSE>>=
help(check.iio)
@
}

\end{itemize}

\subsection{\textcolor{black}{\texttt{check.monotonicity} (a.k.a.\ \texttt{check.single})}}
Investigates the monotonicity assumption using the observable property manifest monotonicity
 (Molenaar \& Sijtsma, 2000, pp.\ 70-77).
In the example, the scores on the first ten items from ACL are used; these are the
items of the scale Communality. First, all result with respect to manifest monotonicity are
saved in \texttt{monotonicity.results}.
Simply typing \texttt{monotonicity.results} produces a list with lots of output for each item.
\texttt{summary()} and \texttt{plot()} reduce this output by giving a summary of the results
and graphically displaying the estimated item (step) response functions, respectively.
For interpretation of the output see Molenaar and Sijtsma (2000, chap.\ 6, chap.\ 7).
Without further specifications \texttt{plot()} displays 10 graphs (1 for each item) in a separate R Window,
and requires a hard return to go to the next graph. Figure~\ref{F8} (p.\ \pageref{F8}) shows the 10 graphs.

{\inputfont
<<label=E4,eval=FALSE>>=
data(acl)
Communality <- acl[,1:10]
monotonicity.results <- check.monotonicity(Communality)
summary(monotonicity.results)
plot(monotonicity.results, items = c(1,2))
@
}

{\inputfont
<<label=E4,echo=FALSE>>=
Communality <- acl[,1:10]
monotonicity.results <- check.monotonicity(Communality)
summary(monotonicity.results)
@
}

{\inputfont
<<label=E4Afig,echo=FALSE,include=FALSE>>=
layout(matrix(1:1,nrow=1,byrow=TRUE))
plot(monotonicity.results, ask=FALSE, items = 1)
@
}

{\inputfont
<<label=E4Bfig,echo=FALSE,include=FALSE>>=
plot(monotonicity.results, ask=FALSE, items = 2)
@
}

%\begin{landscape}
\begin{figure}
\begin{center}
{\inputfont
<<label=E4Afigplot, fig=TRUE, echo=FALSE>>=
<<E4Afig>>
@
}
\end{center}
\begin{center}
{\inputfont
<<label=E4Bfigplot, fig=TRUE, echo=FALSE>>=
<<E4Bfig>>
@
}
\end{center}
\label{F8}
\end{figure}
%\end{landscape}

Variations of \texttt{check.monotonicity} (output not shown) are the following.

\begin{itemize}

\item Other values for \texttt{minvi} and \texttt{minsize} (Molenaar \& Sijtsma, 2000, pp.\ 45-46) .

{\inputfont
<<label=E4A, eval=FALSE>>=
check.monotonicity(Communality, minvi=0.00, minsize=50)
@
}

 \item Plot the results for items 1 and 2 only

{\inputfont
<<label=E4B, eval=FALSE>>=
plot(check.monotonicity(Communality), item=c(1,2))
@
}

\item Save graphs in a pdf file. \texttt{ask=FALSE} assures that no hard return is required between subsequent graphs.
      The functions \texttt{pdf()} and \texttt{dev.off()} are not part of \texttt{mokken}.

{\inputfont
<<label=E4C, eval=FALSE>>=
pdf("monotonicity.pdf")
plot(monotonicity.results, ask=FALSE)
dev.off()
@
}

\item For more information type

{\inputfont
<<label=E4D,eval=FALSE>>=
help(check.monotonicity)
@
}

\end{itemize}

\subsection{\texttt{check.pmatrix}}

Investigates the assumption of nonintersecting item step response functions using the P$++$ and P$-$$-$ matrix
  (Molenaar \& Sijtsma, 2000, pp.\ 80-85).
In the example, the scores on the first ten items from ACL are used; these are the
items of the scale Communality. First, all result with respect to the P$++$ (indicted by \texttt{ppp}) and
P$-$$-$ (indicated by \texttt{pmm}) matrix are
saved in \texttt{pmatrix.results}.
Simply typing \texttt{pmatrix.results} produces a list with lots of output for each item.
\texttt{summary()} and \texttt{plot()} reduce this output by giving a summary of the results
and graphically displaying the estimated item (step) response functions, respectively.
For interpretation of the output see Molenaar and Sijtsma (2000, pp.\ 80-85).
Without further specifications \texttt{plot()} (no output shown) displays 20 graphs (2 for each item) in a separate R Window,
and requires a hard return to go to the next graph.

{\inputfont
<<label=E5, eval=FALSE>>=
data(acl)
Communality <- acl[,1:10]
pmatrix.results <- check.pmatrix(Communality)
summary(pmatrix.results)
plot(pmatrix.results)
@
}

{\inputfont
<<label=E5, include=FALSE>>=
pmatrix.results <- check.pmatrix(Communality)
summary(pmatrix.results)
@
}

Variations of \texttt{check.pmatrix} are the following.

\begin{itemize}

\item Other values for \texttt{minvi} (Molenaar \& Sijtsma, 2000, pp.\ 45-46) .

{\inputfont
<<label=E5A, eval=FALSE>>=
check.pmatrix(Communality, minvi=0.00)
@
}

\item Plot the results for P$++$, for items 1 and 2 only, and plot the results for P$-$$-$ for item 5.

{\inputfont
<<label=E5B, eval=FALSE>>=
plot(check.pmatrix(Communality), pmatrix="ppp", item=c(1,2))
plot(check.pmatrix(Communality), pmatrix="pmm", item=5)
@
}

\item Save graphs in a pdf file. \texttt{ask=FALSE} assures that no hard return is required between subsequent graphs.
 The functions \texttt{pdf()} and \texttt{dev.off()} are not part of \texttt{mokken}.

{\inputfont
<<label=E5C, eval=FALSE>>=
pdf("pmatrix.pdf")
plot(pmatrix.results, ask=FALSE)
dev.off()
@
}

\item For more information type

{\inputfont
<<label=E5D,eval=FALSE>>=
help(check.pmatrix)
@
}

\end{itemize}

\subsection{\texttt{check.reliability}}

Computes reliability coefficients $\rho$ (a.k.a., the MS statistic; Molenaar \& Sijtsma, 1984, 1988;
Sijtsma \& Molenaar, 1987; Van der Ark, 2010), Cronbach's (1951) alpha, and lambda-2 (Guttman, 1945).
In the example, the scores on the first ten items from ACL are used; these are the
items of the scale Communality.

{\inputfont
<<label=E6>>=
data(acl)
Communality <- acl[,1:10]
check.reliability(Communality)
@
}

\subsection{\texttt{check.restscore}}

 Investigates the assumption of nonintersecting item step response functions using method restscore
  (Molenaar \& Sijtsma, 2000, pp.\ 77-80).
 In the example, the scores on the first ten items from ACL are used; these are the
   items of the scale Communality. First, all result with respect to method restscore are
    saved in \texttt{restscore.results}.
   Simply typing \texttt{restscore.results} produces a list with lots of output for each item pair.
   \texttt{summary()} and \texttt{plot()} reduce this output by giving a summary of the results
   and plotting the estimated item (step) response functions, respectively.
   For interpretation of the output see Molenaar and Sijtsma (2000, pp.\ 77-80).
   Without further specifications \texttt{plot()} displays $\frac 1 2 \times 10 \times 9 =45$ graphs
   (1 for each item pair) in a separate R Window,
   and requires a hard return to go to the next graph. Figure~\ref{F9} (p.\ \pageref{F9}) shows
   the rest score plots for the first two item pairs.

{\inputfont
<<label=E7, eval=FALSE>>=
data(acl)
Communality <- acl[,1:10]
restscore.results <- check.restscore(Communality)
summary(restscore.results)
plot(restscore.results, item.pairs = c(1,2))
@
}

{\inputfont
<<label=E7, echo=FALSE>>=
Communality <- acl[,1:10]
restscore.results <- check.restscore(Communality)
summary(restscore.results)
@
}

{\inputfont
<<label=E7Afig,echo=FALSE,include=FALSE>>=
plot(restscore.results, ask=FALSE, item.pairs = 1)
@
}

{\inputfont
<<label=E7Bfig,echo=FALSE,include=FALSE>>=
plot(restscore.results, ask=FALSE, item.pairs = 1)
@
}

%\begin{landscape}
\begin{figure}
\begin{center}
{\inputfont
<<label=E7Afigplot, fig=TRUE, echo=FALSE>>=
<<E7Afig>>
@
}
\end{center}
\begin{center}
{\inputfont
<<label=E7Bfigplot, fig=TRUE, echo=FALSE>>=
<<E7Bfig>>
@
}
\end{center}
\label{F9}
\end{figure}
%\end{landscape}


Variations of \texttt{check.restscore} are the following.

\begin{itemize}

\item Other values for \texttt{minvi} and \texttt{minsize} (Molenaar \& Sijtsma, 2000, pp.\ 45-46) .

{\inputfont
<<label=E7A, eval=FALSE>>=
check.restscore(Communality, minvi=0.00, minsize=50)
@
}

\item Plot the results for all item pairs.

{\inputfont
<<label=E7B, eval=FALSE>>=
plot(check.restscore(Communality))
@
}

\item Save graphs in a pdf file. \texttt{ask=FALSE} assures that no hard return is required between subsequent graphs.
 The functions \texttt{pdf()} and \texttt{dev.off()} are not part of \texttt{mokken}.

{\inputfont
<<label=E7C, eval=FALSE>>=
pdf("restscore.pdf")
plot(restscore.results, ask=FALSE)
dev.off()
@
}

\item For more information type

{\inputfont
<<label=E7D,eval=FALSE>>=
help(check.restscore)
@
}

\end{itemize}

\subsection{\texttt{check.groups}}
The package \texttt{mokken} does not yet have a function \texttt{check.groups}, which---in analogy to the function\texttt{CHECK=GROUPS}
 in the software program MSP (Molenaar \& Sijtsma, 2000, pp.\ 85-88)---may have been expected.

Some analyses can be conducted using standard R commands.
The example shows how scalability coefficient $H$ is computed for the first ten items from ACL, constituting the scale Communality,
 for respondents having scores, 0 or 1, 2, 3, and 4, respectively, on item 11 (Achievement). Also, see section~\ref{R.commands}.

{\inputfont
<<label=E8>>=
data(acl)
Communality <- acl[,1:10]
Group <- acl[,11]
coefH(Communality[Group==0|Group==1,])$H
coefH(Communality[Group==2,])$H
coefH(Communality[Group==3,])$H
coefH(Communality[Group==4,])$H
@
}

\chapter{Examples of Mokken scale analysis in R}
\label{example}
This chapter shows the code for producing the tables in Sijtsma and Molenaar (2003).
\section{Table 3.1}
  \begin{description}
   \item Get the transitive reasoning data, and split them into the grades (first column of the data matrix),
   and the items scores (the remaining columns in the data matrix).
{\inputfont
<<label=Table.3.1A>>=
library(mokken)
data(transreas)
grades <- transreas[,1]
item.scores <- transreas[,-1]
@
}
  \item Obtaining the overall mean scores, and the mean scores per grade

{\inputfont
<<label=Table.3.1B>>=
apply(item.scores,2,mean)
apply(item.scores[grades==2,],2,mean)
apply(item.scores[grades==3,],2,mean)
apply(item.scores[grades==4,],2,mean)
apply(item.scores[grades==5,],2,mean)
apply(item.scores[grades==6,],2,mean)
@
}

  \item Construction of Table~3.1 (advanced R code).

{\inputfont
<<label=Table.3.1C>>=
Total.group <- round(apply(item.scores,2,mean),2)
for (i in 2:6) assign(paste("Grade.",i,sep=""),
 round(apply(item.scores[grades==i,],2,mean),2))
Task <- c(9,12,10,11,4,5,2,7,3,1,8,6)
Property <- attributes(transreas)$property
Format <- attributes(transreas)$format
Objects <- attributes(transreas)$objects
Measures <- attributes(transreas)$measures
Table.3.1 <- data.frame(Task,Property,Format,Objects,Measures, Total.group,Grade.2,Grade.3,Grade.4,Grade.5,Grade.6)
Table.3.1
@
}

\end{description}

\section{Table 3.2}

\begin{description}

\item To get the data, see Table 3.1.

\item Obtain scalability coefficients and $Z$ coefficients for items and total scale.
{\inputfont
<<label=Table.3.2B>>=
coefH(item.scores)$Hi
coefH(item.scores)$H
coefZ(item.scores)$Zi
coefZ(item.scores)$Z
@
}

\item Obtain scalability coefficients and $Z$ coefficients for items and total scale,
           when the pseudo items (2 and 4) are deleted

{\inputfont
<<label=Table.3.2C>>=
coefH(item.scores[,-c(2,4)])$Hi
coefH(item.scores[,-c(2,4)])$H
coefZ(item.scores[,-c(2,4)])$Zi
coefZ(item.scores[,-c(2,4)])$Z
@
}
     \item Construction of Table 3.2 (advanced R code).

{\inputfont
<<label=Table.3.2D>>=
Task <- c("9","12","10","11","4","5","2","7","3","1","8","6", "Total item set")
Property <- c(attributes(transreas)$property,"")
Format <- c(attributes(transreas)$format,"")
Table.3.2 <- data.frame(Task,Property,Format,matrix(NA,13,8))
analysis <- list(c(1:12),c(1,3,5:12),c(1,3,6,8:12),c(1,3,8:12))
k <- 3
for (i in 1:4) for (j in 1:2){
 k <- k + 1
 Table.3.2[c(analysis[[i]],13),k] <-
 c(round(coefH(item.scores[,analysis[[i]]])$Hi,2),
 round(coefH(item.scores[,analysis[[i]]])$H,2))
}
dimnames(Table.3.2)[[2]][4:11] <- paste(c("k=12","k=12",
 "k=10","k=10","k=8","k=8","k=7","k=7"),c("Hi","Zi"))
Table.3.2
@
}

    \end{description}

\section{Table 5.1}

\begin{description}

\item To get the data, see Table 3.1.
\item Automated item selection algorithm

{\inputfont
<<label=Table.5.1A>>=
scale <- aisp(item.scores, verbose=FALSE)
@
}

\item Construction of Table 5.1 (advanced R code).

{\inputfont
<<label=Table.5.1B>>=
scale.1 <- c(12,8,1,11,9,3,10)
scale.2 <- c(7,5)
Hi.top <- matrix(NA,8,6)
for (i in 1:6)
Hi.top[1:(i+1),i] <- round(coefH(item.scores[,scale.1[1:(i+1)]])$Hi,2)
for (i in 1:6)
Hi.top[8,i] <- round(coefH(item.scores[,scale.1[1:(i+1)]])$H,2)
dimnames(Hi.top)[[2]] <- paste("Step",1:6)
Table.5.1.top <- data.frame(
 Task = c(Task[scale.1],"Total H"),
 Property= c(Property[scale.1],""),
 Format=c(Format[scale.1],""),
 Pi = c(round(apply(item.scores[,scale.1],2,mean),2),NA)
)
 Table.5.1.top <- cbind(Table.5.1.top,Hi.top)
 Table.5.1.top
@
}
\end{description}

\section{Table 5.2}

\begin{description}

  \item Get the data, and dichotomize the scores, compute the $P$-values

{\inputfont
<<label=Table.5.2A>>=
data(cavalini)
X <- cavalini
X[cavalini < 2] <- 0
X[cavalini > 1] <- 1
apply(X,2,mean)
@
}

\item Make the table (advanced R code)

{\inputfont
<<label=Table.5.2B>>=
Table.5.2 <- data.frame(1:17, attributes(X)$labels,
        round(apply(X,2,mean),2))
dimnames(Table.5.2)[[2]] <- c("Item.number","Item.text","Pi")
rownames(Table.5.2) <- NULL
Table.5.2
@
}

\end{description}

\section{Table 5.3}

\begin{description}

\item Get the data, and dichotomize the scores, see previous example

\item Automated item selection algorithm with different values for the lower bound.

{\inputfont
<<label=Table.5.3A, eval = FALSE>>=
aisp(X,lowerbound=0.00, verbose = FALSE)
aisp(X,lowerbound=0.05, verbose = FALSE)
aisp(X,lowerbound=0.10, verbose = FALSE)
# etc.
@
}

\item Make the table (advanced R code)

{\inputfont
<<label=Table.5.3B>>=
lower.bound <- seq(0,.6,by=.05)
scaling.results <- matrix(NA,length(lower.bound),ncol(X))
for (i in 1:length(lower.bound)) scaling.results[i,] <- aisp(X, lowerbound=lower.bound[i],verbose=FALSE)
equal <- function(x,n) which(x==n)
scale.1 <- sapply(apply(scaling.results,1,"equal", 1), paste,collapse=" ")
scale.2 <- sapply(apply(scaling.results,1,"equal", 2), paste,collapse=" ")
scale.3 <- sapply(apply(scaling.results,1,"equal", 3), paste,collapse=" ")
scale.4 <- sapply(apply(scaling.results,1,"equal", 4), paste,collapse=" ")
scale.5 <- sapply(apply(scaling.results,1,"equal", 5), paste,collapse=" ")
Table.5.3 <- data.frame(lower.bound, scale.1,scale.2, scale.3,scale.4,scale.5)
Table.5.3
@
}

\end{description}

\section{Table 5.4}

\begin{description}

\item Get the data, and dichotomize the scores, see previous example
\item Automated item selection algorithm with two different values for the lower bound.

{\inputfont
<<label=Table.5.4A>>=
scale.3 <- aisp(X,lowerbound=0.30)
scale.35 <- aisp(X,lowerbound=0.35)
@
}

\item Make the table (advanced R code)

{\inputfont
<<label=Table.5.4B>>=
scale.30 <- aisp(X,lowerbound=0.30,verbose=F)
max.scale <- max(scale.30)
Table.5.4.left <- data.frame()
for (i in 1:max.scale){
  max.item <- max(length(scale.30[scale.30==i]))
  Scale <- c(i,rep("",max.item-1))
  Item.30 <- which(scale.30==i)
  Hi.30 <- round(coefH(X[,scale.30==i])$Hi,2)
  H.30 <- c(rep("",max.item-1),round(coefH(X[,scale.30==i])$H,2))
  Table.5.4.left <- rbind(Table.5.4.left,data.frame(Scale=Scale,
     Item=Item.30,Hi=Hi.30,H=H.30),c("","","",""))
}
rownames(Table.5.4.left) <- NULL
Table.5.4.left
@
}

{\inputfont
<<label=Table.5.4C>>=
scale.35 <- aisp(X,lowerbound=0.35,verbose=F)
max.scale <- max(scale.35)
Table.5.4.right <- data.frame()
for (i in 1:max.scale){
  max.item <- max(length(scale.35[scale.35==i]))
  Scale <- c(i,rep("",max.item-1))
  Item.35 <- which(scale.35==i)
  Hi.35 <- round(coefH(X[,scale.35==i])$Hi,2)
  H.35 <- c(rep("",max.item-1),round(coefH(X[,scale.35==i])$H,2))
  Table.5.4.right <- rbind(Table.5.4.right,data.frame(Scale=Scale,
     Item=Item.35,Hi=Hi.35,H=H.35),c("","","",""))
}
rownames(Table.5.4.right) <- NULL
Table.5.4.right
@
}

\end{description}

\section{Table 6.1}

\begin{description}

\item Get the data. The two pseudo task. Item 2 (column 3) and item 4 (column5) were not considered.
        Also, the first column (Group) is removed from the data.
        Tasks 3 and 4 (items 5 and 9) were investigated in detail. This is the item pair number 21.


{\inputfont
<<label=Table.6.1>>=
library(mokken)
data(transreas)
X <- transreas[,-c(1,3,5)]
check.restscore(X,minsize=2)$results[[21]]
check.restscore(X,minsize=40)$results[[21]]
plot(check.restscore(X,minsize=2),item.pairs=21)
plot(check.restscore(X,minsize=40),item.pairs=21)
R <- apply(X[,-c(3,7)],1,sum)
table(X[,3],X[,7],R)
as.numeric(table(X[,3][R < 5],X[,7][R < 5]))
@
}

\end{description}

\section{Table 6.2}

\begin{description}

\item Get the data. The two pseudo task. Item 2 (column 3) and item 4 (column5) were not considered.
        Also, the first column (Group) is removed from the data.

{\inputfont
<<label=Table.6.2A>>=
library(mokken)
data(transreas)
X <- transreas[,-c(1,3,5)]
Task <- c(9,10,4,5,2,7,3,1,8,6)
ppp <- check.pmatrix(X)$Ppp
dimnames(ppp) <- list(Task,Task)
round(ppp,2)
@
}


{\inputfont
<<label=Table.6.2B>>=
pmm <- check.pmatrix(X)$Pmm
dimnames(pmm) <- list(Task,Task)
round(pmm,2)
@
}

\end{description}


\section*{Acknowledgements}
Thanks are due to Wybrandt van Schuur for comments on the first
draft of this report.
\section*{References}
\begin{description}
\item Baron, J., \& Li, Y. (2007).
  \emph{Notes on the use of R for psychology experiments and questionnaires}.
  Unpublished manuscript. Retrieved from
   \url{http://www.psych.upenn.edu/~baron/rpsych/rpsych.html}

 \item
  Cronbach, L. (1951).
  Coefficient alpha and the internal structure of tests.
  \emph{Psychometrika, 16}, 297-334.

 \item
  Guttman, L. (1945).
  A basis for analyzing test-retest reliability.
  \emph{Psychometrika, 10},255-282.

 \item
   Ligtvoet, R., Van der Ark, L. A., Te Marvelde, J. M., \& Sijtsma, K. (2010).
   Investigating an invariant item ordering for polytomously scored items.
   \emph{Educational and Psychological Measurement.}

 \item
  Ligtvoet, R, van der Ark, L. A. , Bergsma, W. P., \& Sijtsma, K. (2010).
  Polytomous latent scales for the investigation of the ordering of items.
  Manuscript submitted for publication.

 \item
  Mokken, R. J. (1971).
  \emph{A Theory and Procedure of Scale Analysis}. Berlin, Germany: De Gruyter.

 \item
  Molenaar, I. W. and K. Sijtsma (1984).
  Internal consistency and reliability in Mokken's nonparametric item response model.
  \emph{Tijdschrift voor onderwijsresearch, 9}, 257--268.

 \item
  Molenaar, I. W. and K. Sijtsma (1988).
  Mokken's approach to reliability estimation extended to multicategory items.
  \emph{Kwantitatieve methoden, 9(28)}, 115-126.

 \item
  Molenaar, I.W., \& Sijtsma, K. (2000).
  User's Manual MSP5 for Windows [Software manual].
  Groningen, The Netherlands: IEC ProGAMMA.

 \item
  Muenchen, R. A. (2008).
  \emph{R for SAS and SPSS Users}. Berlin: Springer.

 \item
  Paradis, E. (2005). \emph{R for beginners}. Unpublished manuscript.
  Retrieved from \url{http://cran.r-project.org/doc/contrib/Paradis-rdebuts_en.pdf}

 \item
  R Development Core Team (2006).
  \emph{R: A Language and Environment for Statistical Computing}.
  Vienna, Austria: R Foundation for Statistical Computing.

 \item R Development Core Team (2009).
  \emph{An Introduction to R}. Unpublished manuscript.
  Retrieved from \url{http://cran.r-project.org/doc/manuals/R-intro.html}

 \item
  Sijtsma, K. and I. W. Molenaar (1987).
  Reliability of test scores in nonparametric item response theory.
  \emph{Psychometrika, 52},79-97.

 \item
  Sijtsma, K., \& Molenaar, I. W. (2002).
  \emph{Introduction to nonparametric item response theory}. Thousand Oaks, CA: Sage.

 \item
  Straat, J. H., Van der Ark, L. A., \& Sijtsma, K. (2008).
  Comparing optimization algorithms for item selection in Mokken scale analysis.
  Paper submitted for publication.

 \item
  Van der Ark, L. A. (2007).
  Mokken scale analysis in R.
 \emph{Journal of Statistical Software, 20} (11), 1-19.

 \item
  Van der Ark, L. A. (2010).
  Computation of the Molenaar Sijtsma statistic.
  In A. Fink, B. Lausen, W. Seidel, \& A. Ultsch (Eds.),
  \emph{Advances in data analysis, data handling and business intelligence} (pp.\ 775-784).
  Berlin: Springer.

% \item
%  Verweij, A. C., Sijtsma, K., and Koops, W. (1996).
%  A Mokken scale for transitive reasoning suited for longitudinal research.
%  \emph{International Journal of Behavioral Development, 23}, 241-264.

\end{description}
\end{document}
